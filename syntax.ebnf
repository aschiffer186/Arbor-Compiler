# Note, this grammar is at least as permissive as the final Bison grammar, but is not equivalent to it 

# Type system 
type ::= ["const"] non-reference-type | ["const"] reference-type
non-reference-type ::= type-core | type-core '*' | type-core '[' [int-literal] ']'
type-core ::= identifier [type-template-parameters]
type-template-parameters ::= '!' '(' type-list ')'
type-list ::= type | type-list ',' type
reference-type ::= "ref" non-reference-type | "rref" non-reference-type

# Expressions
expresion ::=
    # Primary expressions (cannot be broken down further)
    literal 
    identifier
    "this"
    "super"
    # Binary expressions
    expression '+' expression
    expression '-' expression
    expression '*' expression 
    expression '/' expression 
    expression '//' expression # integer division
    expression '^^' expression # exponentiation 
    expression '%' expression
    expression '+=' expression # xx and modify expressions
    expression '-=' expression
    expression '*=' expression 
    expression '/=' expression 
    expression '//=' expression 
    expression '^^=' expression
    expression '%=' expression
    expression '<' expression 
    expression '<=' expression
    expression '>' expression
    expression '<=' expression
    expression '<=>' expression # Three-way comparison
    expression '==' expression 
    expression '!=' expression
    expression '&&' expression
    expression '||' expression 
    expression '&' expression # Bitwise AND
    expression '|' expression # Bitwse OR 
    expression '^' expression # Bitwise XOR
    expression '~' expression # Bitwise NOT
    expression '>>' expression # Bitwise shift left
    expression '<<' expression # Bitwise shift right
    expression '=' expression 
    # Unary expressions
    '++' expression
    '--' expression
    expression '++'
    expression '--'
    '-' expression
    '*' expression # Pointer dereference (note lack of address of)
    '!' expression # unary-negation
    #Miscelaneous expressions
    '(' expression ')' '?' expression ':' expression # Ternary operatory
    '(' expression ')'
    '[' array-index-list ']'
    expression '.' expression 
    expression '->' expression 
    "typeof" '(' expression ')'
    "castas" '(' type ')' '(' expression ')'
    '{' [expression-list] '}'
    variable-declaration
    lambda-expression
    function-call
    new-expression
# Helper non-terminals
array-index-list ::= array-index | array-index-list ',' array-index
array-index ::= expression | [expression] ':' [expression]
variable-declaration ::= "let" variable-declaration-block-list 
variable-declaration-block-list ::= variable-declaration-block | variable-declaration-block-list ',' variable-declaration-block
variable-declaration-block ::= type identifier ['=' expression]
lambda-expression ::= '(' function-argument-list ')' '=>' "{" block-statement "}" '->' return-type-list
function-call ::= expression '(' [function-call-list] ')'
function-call-list ::= function-call-arg | function-call-list ',' function-call-arg
function-call-arg ::= expression | identifier '=' expression
expression-list ::= expression | expression-list ',' expresion
new-expresion ::= "new" ["heap"] type '(' [expression-list] ')'

# Statements
statement ::= 
    block-statement
    conditional-statement 
    loop-statement
    exception-statement
    clean-up-statement
    jump-statement
    expression-statement
    no-op-statement
block-statement ::= statement | block-statement statement
loop-statement ::= while-loop-statement | do-loop-statement | for-loop-statement
while-loop-statement ::= "while" '(' expression ')' block-statement "endwhile"
do-loop-statement ::= "do" block-statement "while" '(' expression ')' "endwhile"
for-loop-statement ::= "for" '(' for-loop-condition ')' block-statement "endfor"
for-loop-condition ::= 
    [expression] ';' [expression] ';' [expression]
    variable-declaration 'in' expression
conditional-statement ::= if-statement-sequence | switch-statement
if-statement-sequence ::= if-statement [else-if-statements] [else-statement]
if-statement ::= "if" '(' expression ')' block-statement
elseif-statements ::= elseif-statement | elseif-statements elseif-statement
elseif-statement ::= "else-if" '(' expression ')' block-statement
else-statement ::= "else" block-statement
switch-statement ::= "switch" '(' expression ')' case-blocks [default-block] "endswitch"
case_blocks ::= case-block | case-blocks case-block
case-block ::= "case" expression ':' block-statement jump-statement |
default-block ::= "default" ":" block-statement jump-statement
exception-statement ::= try-block catch-blocks "endcatch"
try-block ::= "try" block-statement "endtry"
catch-blocks ::= catch-block | catch-blocks catch-block
catch-block ::= "catch" '(' variable-declaration ')' block-statement | "catch-all" block-statement
# The clean-up statement provides an extension to the RAII idiom that Arbor follows. It allows 
# the user to specify at run-time code (in the form of a function pointer, anoynomous function, or lambda), 
# additional code to be run when the object is destroyed. The clean-up code is called before the destructor 
# is called. 
#   file f; 
#   cleanup(f, () => {print("In clean up wooo");} -> void);
#   file* f2
#   cleanup(*f2, () => {print("In clean up 2 wooo");} -> void)
# Whenever ~f() is called, the lambda will be called. If more than one clean-up statements are provided, the 
# code will be expected in the order the clean-up statements are created. Clean-up statements are per variable 
# not per type. 
clean-up-statement ::= "cleanup" '(' identifier ',' clean-up-arg ')' ';'
clean-up-arg ::= lambda-expression | function?? | identifier 
jump-statement ::= 
    "return" ';'
    "break" ';'
    "continue" ';'
    "throw" expression ';'
    "rethrow" ";"
    "yield" ';'
    "goto" identifier ':'
expression-statement ::= expression ';'
no-op-statement ::= ';'

#functions 
function = function-header block-statement "endfunc"
anoynmous_function = anoynmous_function_header block_statement "endfunc"
function-header = "func" ["virtual"] ["static"] ["compeval"] identifier '(' function-argument-list ')' throwable-expression '->' return-types-list
function-argument-list ::= function-argument | function-argument-list ',' function-argument 
function-argument ::= type ['...'] identifier ['=' expression]
throwable-expression ::= "nothrowable" ['(' expression ')']
return_types_list ::= return-type | return_types-list "," return-type
return-type ::= type | "typeof" "(" expression ")"
anoynmous_function_header = "func" ["compeval"] '(' function-argument-list ')' throwable-expression '->' return-types
operator-overload = operator-overload-header block-statement "endfuc" | operator-overload-header '=' function-options ';'
operator-overload = "operator" operator '(' function-argument-list ')' throwable-expression '->' return-types
function-options = "default" | "delete"
callable = function | operator-overload

program = [callables]
callables = callable | callables callable
